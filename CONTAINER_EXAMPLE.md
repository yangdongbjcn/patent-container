下面举一个具体的例子，帮助读者了解“专利容器”。专利大数据中的技术分解表常常表示为多个树节点的专利集合。

1）每个树节点对应着一个树根到该节点的路径。
例如“输入设备-触摸屏-电容触摸屏”，其中“输入设备”是该技术分解表的树根，“电容触摸屏”是当前的树节点的内容。而“触摸屏”则是从树根到该节点的路径中的一个节点。

2）每个树节点还对应着一个专利集合。
例如，对于“电容触摸屏”节点来说，该专利集合是与“电容触摸屏”相关的专利集合，而不包括“电阻触摸屏”的专利集合，也不包括“鼠标”的专利集合。而对于“触摸屏”节点来说，其对应的专利集合是所有触摸屏相关的专利集合，不仅应当包括电容触摸屏，也包括电阻触摸屏、电磁触摸屏等的专利。

父节点的专利集合涵盖子节点的专利集合，如果对父节点和子节点的专利集合分别进行存储，很容易造成数据重复存储。因而可以根据需要选择，父节点不存储子节点的专利集合，而是只存储所有子节点不存储的其他数据。

专利集合一般存储在一个电子表格文件中。电子表格文件是以二维表的形式存储专利数据，一般一行是一条专利，多行是多个专利。为了更加直观，可以将电子表格文件的名称命名为该树节点的路径名称，例如树节点“电容触摸屏”对应的电子表格文件的名称可以是“输入设备-触摸屏-电容触摸屏.xls”。该技术分解表对应的电子表格文件可有如下：“输入设备-触摸屏-电容触摸屏.xls”、“输入设备-触摸屏-电阻触摸屏.xls”、“输入设备-触摸屏.xls”、“输入设备-鼠标.xls”、“输入设备-键盘.xls”和“输入设备.xls”，一共6个文件。

对于技术分解表的根节点“输入设备”来说，从根节点发散出多个树节点，这些树节点都要存储在同一个树类型容器中。

使用容器存储上述技术分解表时，实际输入的是上述6个电子表格文件。容器首先从6个电子表格文件的文件名中，识别出该技术分解表的结构。即：

1）该技术分解表一共具有6个节点，其名称分别是“输入设备”、“键盘”、“鼠标”、“触摸屏”、“电阻触摸屏”和“电容触摸屏”。为此，分别建立6个容器存储这6个节点。

2）该技术分解表的结构关系，分别存储在这6个容器的嵌套关系上。例如，“输入设备”容器位于树结构的根部，“输入设备”容器中嵌套着3个子容器，“键盘”子容器、“鼠标”子容器和“触摸屏”子容器。而“触摸屏”子容器又嵌套着2个子容器，“电阻触摸屏”子容器和“电容触摸屏”子容器。

假设容器的使用者编写了一个计算申请量年度趋势的算法。该算法从容器的二维表中提取“申请日”，然后统计该容器的专利集合在各个年份上的申请量分布曲线。假设容器中只存储着2010年到2015年的专利数据。

假设该算法具有如下的函数结构：hist = f(apd_list)。其中apd_list表示专利列表中申请日这一列。变量hist表示计算得到的年度申请量，那么容器使用者只能看到2010年到2015年的申请趋势。那么hist就是一个具有6个元素的列表，分别代表2010年到2015年6年的申请量。

容器的使用者使用容器时，hist对应着二维表中的一列，该列的每一个元素应当具有“索引”值。因此，从申请日信息中提取到的“2010”到“2015”这6个数作为索引值是比较恰当的，也具有实际的专利语义。因此在容器中存储的hist，比算法本身多了6个索引值。

而容器的使用者下一次使用该容器时，可能想看一下2000年到2015年的年度申请量趋势。由于上次容器计算了2010年到2015年的趋势，因此容器中必然是存储着2010年到2015年的专利数据的。因此容器的使用者需要关注下，如果容器中没有存储2000年到2009年的数据，那么容器的使用者需要向容器中载入数据，此时容器的数据发生了“更新”，具体地说是发生了“增量”更新。

此时容器的使用者只需要运行下容器的“更新操作”，不必重新编写函数，也不必调整函数的参数。由于容器的数据发生了增量，因此更新之后的输出自然就是2000年到2015年的年度趋势曲线了。


更多信息请访问微信公众号yangdongpatent，或者直接访问网站http://zlrq.cn。
